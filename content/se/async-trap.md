+++
title="Ловушка асинхронности"
date=2025-09-19
[taxonomy]
tags=["software", "system-design", "architecture"]
+++

# Ловушка асинхронности.

Есть такая шутка: "Как пройти на собеседовании секцию по system design? Просто делай всё асинхронным". Ставь кафку - и не парься.
Но так ли это беспроблемно? Давайте разберёмся.

Асинхронность сама по себе не обязательно делает систему лучше и уж точно не убирает связанность.
Нагляднее всего это видно, когда нужно поменять атрибутный состав в уже работающей интеграции.
Обратная совместимость не всегда возможна. Игнорирование незнакомых полей не всегда работает.
Вот тут-то и начинается веселье.

Брокер сообщений ничего не знает о схеме ваших данных (schema awareness) - для него это просто байты.
Поэтому если потребитель получит данные в новом, незнакомом для него формате, он либо упадёт, либо будет вынужден пропустить это сообщение.

Это создаёт **скрытую зависимость** (читай: связанность) по разработке: **пока все потребители не научились читать новые сообщения, поставщик не вправе эти новые сообщения писать.**
И даже после обновления потребителя придётся какое-то время поддерживать оба формата - старый и новый - ведь в топике могут оставаться старые сообщения.

## Что делать?

Есть два подхода, но оба они требуют признать один факт, контринтуитивный для многих: **ваши сервисы должны уметь работать с несколькими форматами данных одновременно**.
Нет, это не дублирование кода. Это необходимость, если хочется плавную и независимую миграцию.

1. **[[Tolerant Reader|Гибкий потребитель]].** Код сервиса-потребителя (да и поставщика, для rollback) должен содержать парсеры для нескольких версий контракта. Это плата за независимые релизы и возможность дочитать старые сообщения.
2. **Новый топик для нового формата.** Поставщик начинает писать в новый топик, а потребители переключаются на него по мере готовности. Старый топик и старый формат какое-то время поддерживаются поставщиком.

	- **Ключевое требование здесь — идемпотентность.** При миграции потребитель может получить одно и то же бизнес-событие в разных форматах, но обработать его должен **лишь однажды**.


## ☠️ Путь к провалу: Lock-step обновление.
А вот отказ от гибкости (в силу ли борьбы с "мёртвым кодом", или в силу поиска Стандартного Обработчика Единого Формата Данных) безнадежно ломает эту схему, сводя ее к очень хрупкому и болезненному lock-step процессу.

В нем придется:
1. Остановить поставщика - вероятно, через отключение фичи.
2. Дождаться обработки всех текущих сообщений всеми потребителями.
3. Обновить **всех** потребителей.
4. Обновить писателя.
5. Очистить текущий топик.
6. Запустить интеграцию снова (начать писать сообщения).

Едва ли такой процесс можно назвать простым и надежным.
Цена такого подхода?
- **Даунтайм системы**;
- **Адская координация**, в которой чем больше участников, тем сложнее - это придётся встраивать в планы каждой из сторон, и, скорее всего, здесь будет огромное число ожиданий;
- **Нулевое право на ошибку**: варианта откатиться назад нет ни  у кого.

Асинхронность - не серебряная пуля. Она не избавляет от связности, а лишь меняет её природу.
За эволюцией контрактов здесь придется следить еще тщательнее, ведь цена нарушения обратной совместимости в асинхронном мире крайне высока.